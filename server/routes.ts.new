import express, { type Express, Request, Response } from "express";
import { createServer, type Server } from "http";
// Import from the auth middleware which re-exports from the authentication module
import { authenticateSession, User, AuthenticatedRequest } from "./middleware/auth";
import apiRouter from "./controllers";
import { getDashboardStats } from "./controllers/dashboard";
import { router as budgetRouter } from "./controllers/budgetController";
import { getBudgetByMis } from './controllers/budgetController';
import { router as budgetNotificationsRouter } from "./controllers/budgetNotificationsController";
import { router as unitsRouter } from "./controllers/unitsController";
import { router as usersRouter } from "./controllers/usersController";
import { router as projectRouter } from "./controllers/projectController";
import { router as documentsRouter } from "./controllers/documentsController";
import templatePreviewRouter from "./routes/template-preview";
import authRouter from "./routes/auth";
import budgetUploadRouter from "./routes/budget-upload"; // Import the budget upload router
import attachmentsRouter from "./controllers/attachments"; // Import for attachments (default export)
import healthcheckRouter from "./routes/healthcheck"; // Import the original healthcheck router
import healthRouter from "./routes/health"; // Import our new enhanced health check router
import sdegdaefkDiagnosticRouter from "./routes/sdegdaefk-diagnostic"; // Import the sdegdaefk.gr diagnostic router
import documentsBrowserHandler from "./middleware/sdegdaefk/documentsBrowserHandler"; // Import browser request handler for /documents
import authBrowserHandler from "./middleware/sdegdaefk/authBrowserHandler"; // Import browser request handler for /auth
// Note: We now use the consolidated documentsController instead of multiple document route files
import { log } from "./vite";
import { supabase } from "./config/db"; // Main supabase client
import { verifyDatabaseConnections } from "./data"; // Database utilities
import { BudgetService } from "./services/budgetService"; // Budget service for operations

export async function registerRoutes(app: Express): Promise<Server> {
  try {
    // TODO: Refactor - Move these direct document routes to the consolidated DocumentController
    // IMPORTANT: Register direct document creation route first to bypass any routing conflicts
    app.post('/api/documents', authenticateSession, async (req: AuthenticatedRequest, res: Response) => {
      try {
        console.log('[DIRECT_ROUTE] Document creation request received:', JSON.stringify(req.body));

        if (!req.user?.id) {
          return res.status(401).json({ message: 'Authentication required' });
        }

        const { unit, project_id, expenditure_type, recipients, total_amount, attachments } = req.body;

        if (!recipients?.length || !project_id || !unit || !expenditure_type) {
          return res.status(400).json({
            message: 'Missing required fields: recipients, project_id, unit, and expenditure_type are required'
          });
        }

        // Get project NA853
        const { data: projectData, error: projectError } = await supabase
          .from('Projects')
          .select('na853')
          .eq('mis', project_id)
          .single();

        if (projectError || !projectData) {
          return res.status(404).json({ message: 'Project not found', error: projectError?.message });
        }

        // Format recipients data
        const formattedRecipients = recipients.map((r: any) => ({
          firstname: String(r.firstname).trim(),
          lastname: String(r.lastname).trim(),
          fathername: String(r.fathername).trim(),
          afm: String(r.afm).trim(),
          amount: parseFloat(String(r.amount)),
          installment: String(r.installment).trim()
        }));

        const now = new Date().toISOString();

        // Create document with exact schema match and set initial status to pending
        const documentPayload = {
          unit,
          project_id,
          project_na853: projectData.na853,
          expenditure_type,
          status: 'pending', // Always set initial status to pending
          recipients: formattedRecipients,
          total_amount: parseFloat(String(total_amount)) || 0,
          generated_by: req.user.id,
          department: req.user.department || null,
          // Instead of contact_number, use telephone field to match the schema
          telephone: req.user.telephone || null,
          user_name: req.user.name || null,
          attachments: attachments || [],
          created_at: now,
          updated_at: now
        };

        console.log('[DIRECT_ROUTE] Document payload prepared:', documentPayload);

        // Insert into database
        const { data, error } = await supabase
          .from('generated_documents')
          .insert([documentPayload])
          .select('id')
          .single();

        if (error) {
          console.error('[DIRECT_ROUTE] Error creating document:', error);
          return res.status(500).json({ 
            message: 'Error creating document', 
            error: error.message,
            details: error.details
          });
        }

        console.log('[DIRECT_ROUTE] Document created successfully:', data.id);
        
        // NOTE: Budget update has been removed from this endpoint to prevent duplicate updates.
        // The budget is now updated only in the V2 document creation endpoint.
        // This prevents duplicate budget history entries.
        
        res.status(201).json({ id: data.id });
      } catch (error) {
        console.error('[DIRECT_ROUTE] Error creating document:', error);
        res.status(500).json({ 
          message: 'Error creating document', 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    });

    // Removed test routes for production code
    
    // VERSION 2 DOCUMENT CREATION ENDPOINT - Direct access for client-side
    // This is the endpoint that the create-document-dialog.tsx component uses
    // TODO: Refactor - Move to DocumentsController and standardize with the v1 endpoint
    app.post('/api/v2-documents', async (req: Request, res: Response) => {
      try {
        console.log('[DIRECT_ROUTE_V2] Document creation request with body:', req.body);
        
        // Check if there's a session but don't require auth for testing
        console.log('[DIRECT_ROUTE_V2] Session info:', (req as any).session);
        
        const { unit, project_id, project_mis, expenditure_type, recipients, total_amount, attachments = [], region } = req.body;
        
        if (!recipients?.length || !project_id || !unit || !expenditure_type) {
          return res.status(400).json({
            message: 'Missing required fields: recipients, project_id, unit, and expenditure_type are required'
          });
        }
        
        // Get project NA853 from Supabase if not provided
        let project_na853 = req.body.project_na853;
        if (!project_na853) {
          console.log('[DIRECT_ROUTE_V2] Fetching NA853 for project with MIS:', project_id);
          
          try {
            // Look up in the Projects table - using the project_id as the MIS value
            const { data: projectData, error: projectError } = await supabase
              .from('Projects')
              .select('na853')
              .eq('mis', project_id)
              .single();
            
            if (!projectError && projectData && projectData.na853) {
              // Use the full NA853 value without stripping non-numeric characters
              project_na853 = String(projectData.na853);
              console.log('[DIRECT_ROUTE_V2] Retrieved NA853 from Projects table:', project_na853);
              
              // If NA853 is empty for some reason, use project_mis as fallback
              if (!project_na853) {
                console.error('[DIRECT_ROUTE_V2] NA853 value is empty:', projectData.na853);
                // Try to use project_mis as fallback
                if (req.body.project_mis) {
                  project_na853 = req.body.project_mis;
                  console.log('[DIRECT_ROUTE_V2] Using project_mis as fallback:', req.body.project_mis);
                } else {
                  // Last resort - use project_id as fallback
                  project_na853 = project_id;
                  console.log('[DIRECT_ROUTE_V2] Using project_id as fallback:', project_id);
                }
              }
            } else {
              // If no data found in Projects table, use project_mis as fallback
              if (req.body.project_mis && !isNaN(Number(req.body.project_mis))) {
                console.log('[DIRECT_ROUTE_V2] Using project_mis directly as numeric fallback:', req.body.project_mis);
                project_na853 = req.body.project_mis;
              } else {
                console.error('[DIRECT_ROUTE_V2] Could not find project in Projects table:', projectError);
                return res.status(400).json({ 
                  message: 'Project not found in Projects table and no fallback available', 
                  error: 'Project NA853 could not be determined'
                });
              }
            }
          } catch (error) {
            console.error('[DIRECT_ROUTE_V2] Error during project lookup:', error);
            
            // If error happens, use project_mis as numeric fallback if available and valid
            if (req.body.project_mis && !isNaN(Number(req.body.project_mis))) {
              console.log('[DIRECT_ROUTE_V2] Using project_mis as numeric fallback due to error:', req.body.project_mis);
              project_na853 = req.body.project_mis;
            } else {
              console.error('[DIRECT_ROUTE_V2] No valid numeric fallback available');
              // Last resort - use 0 as safe numeric value
              project_na853 = '0';
              console.log('[DIRECT_ROUTE_V2] Using safe numeric fallback: 0');
            }
          }
          
          console.log('[DIRECT_ROUTE_V2] Final NA853 value:', project_na853);
        }
        
        // Format recipients data
        const formattedRecipients = recipients.map((r: any) => ({
          firstname: String(r.firstname).trim(),
          lastname: String(r.lastname).trim(),
          fathername: String(r.fathername || '').trim(),
          afm: String(r.afm).trim(),
          amount: parseFloat(String(r.amount)),
          installments: Array.isArray(r.installments) ? r.installments : [String(r.installment || 'ΕΦΑΠΑΞ').trim()],
          installmentAmounts: r.installmentAmounts || {}
        }));
        
        const now = new Date().toISOString();
        
        // Log user authentication status
        console.log('[DIRECT_ROUTE_V2] User info for document creation:', {
          hasSession: !!(req as any).session,
          hasUser: !!(req as any).session?.user,
          userId: (req as any).session?.user?.id,
          userDepartment: (req as any).session?.user?.department
        });

        // Create document payload
        const documentPayload = {
          unit,
          project_id: req.body.project_mis || project_id, // Use numeric project_mis if available
          project_na853,
          expenditure_type,
          status: 'pending', // Always set initial status to pending
          recipients: formattedRecipients,
          total_amount: parseFloat(String(total_amount)) || 0,
          attachments: attachments || [],
          region: region || null, // Add region field
          generated_by: (req as any).session?.user?.id || null, // Add user ID if available
          department: (req as any).session?.user?.department || null, // Add department if available
          created_at: now,
          updated_at: now
        };
        
        console.log('[DIRECT_ROUTE_V2] Inserting document with payload:', documentPayload);
        
        // Insert into database - Use explicit ID generation with max+1 to avoid conflicts
        // First check if we need to handle a conflict case
        const { data: maxIdData } = await supabase
          .from('generated_documents')
          .select('id')
          .order('id', { ascending: false })
          .limit(1)
          .single();
        
        // Get the max ID and add 1
        const newId = (maxIdData?.id || 0) + 100; // Add 100 to ensure we're well clear of any existing IDs
        console.log('[DIRECT_ROUTE_V2] Found max ID:', maxIdData?.id, 'Using new ID:', newId);
        
        // Create a copy of document payload with an explicit new ID
        const finalPayload = { 
          ...documentPayload,
          id: newId
        };
        
        // Insert into database with explicit ID
        const { data, error } = await supabase
          .from('generated_documents')
          .insert([finalPayload])
          .select('id')
          .single();
        
        if (error) {
          console.error('[DIRECT_ROUTE_V2] Supabase error:', error);
          return res.status(500).json({ 
            message: 'Error creating document in database', 
            error: error.message,
            details: error.details
          });
        }
        
        console.log('[DIRECT_ROUTE_V2] Document created successfully with ID:', data.id);
        
        // Update the budget to reflect the document creation
        try {
          // Convert project_id to MIS if needed (project_id or project_mis)
          const projectMIS = req.body.project_mis || project_id;
          console.log('[DIRECT_ROUTE_V2] Updating budget for project:', projectMIS, 'with amount:', documentPayload.total_amount);
          console.log('[DIRECT_ROUTE_V2] Budget update parameters: ', {
            mis: projectMIS, 
            amount: documentPayload.total_amount,
            userId: (req as any).session?.user?.id || 'guest',
            documentId: data.id,
            changeReason: `Δημιουργία εγγράφου ID:${data.id} για το έργο με MIS:${projectMIS}`
          });
          
          const budgetResult = await BudgetService.updateBudget(
            projectMIS,                         // MIS
            documentPayload.total_amount,       // Amount
            (req as any).session?.user?.id || 'guest',  // User ID
            data.id,                            // Document ID
            `Δημιουργία εγγράφου ID:${data.id} για το έργο με MIS:${projectMIS}`  // Change reason
          );
          
          console.log('[DIRECT_ROUTE_V2] Budget update result:', budgetResult.status);
          console.log('[DIRECT_ROUTE_V2] Full budget update response:', JSON.stringify(budgetResult, null, 2));
        } catch (budgetError) {
          console.error('[DIRECT_ROUTE_V2] Error updating budget (document still created):', budgetError);
          console.error('[DIRECT_ROUTE_V2] Budget update error details:', budgetError instanceof Error ? budgetError.message : 'Unknown error');
          // Continue without failing - document is created but budget may not be updated
        }
        
        res.status(201).json({ 
          id: data.id,
          message: 'Document created and stored in database'
        });
      } catch (error) {
        console.error('[DIRECT_ROUTE_V2] Error:', error);
        res.status(500).json({ 
          message: 'Error in direct route', 
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      }
    });

    // Authentication routes
    log('[Routes] Setting up authentication routes...');
    
    // Import the consolidated auth router
    const authApiRouter = await import('./routes/api/auth').then(m => m.default);
    
    // Use the consolidated auth router for all auth routes
    app.use('/api/auth', authApiRouter);
    
    // Note: We are now using the consolidated auth routes from server/routes/api/auth.ts
    // which includes all auth functionality:
    // - Login
    // - Logout
    // - Session management
    // - Password management
    
    // Legacy auth route
    app.use('/auth', authRouter);
    
    // Mock login route for testing
    if (process.env.NODE_ENV !== 'production') {
      log('[Routes] Setting up mock authentication routes (non-production only)...');
      app.use('/api/mock', async (req: Request, res: Response) => {
        const userId = req.query.userId as string;
        if (!userId) {
          return res.status(400).json({ message: 'userId query parameter is required' });
        }
        
        try {
          // Look up the user by ID
          const { data: userData, error: userError } = await supabase
            .from('users')
            .select('*')
            .eq('id', userId)
            .single();
          
          if (userError || !userData) {
            return res.status(404).json({ message: 'User not found' });
          }
          
          // Set the user in the session
          (req as any).session.user = userData;
          await new Promise<void>((resolve, reject) => {
            (req as any).session.save((err: Error) => {
              if (err) reject(err);
              else resolve();
            });
          });
          
          res.json({ message: 'Mock login successful', user: userData });
        } catch (error) {
          console.error('Error in mock login:', error);
          res.status(500).json({ message: 'Error in mock login' });
        }
      });
    }
    
    // Browser document handler middleware for sdegdaefk.gr integration
    app.use('/documents', documentsBrowserHandler);
    
    // Browser auth handler middleware for sdegdaefk.gr integration
    app.use('/auth/login', authBrowserHandler);
    
    // Dashboard routes
    log('[Routes] Setting up dashboard routes...');
    
    // GET Dashboard stats endpoint
    app.get('/api/dashboard/stats', authenticateSession, async (req: AuthenticatedRequest, res: Response) => {
      try {
        const stats = await getDashboardStats(req.user);
        res.json({ status: 'success', data: stats });
      } catch (error) {
        console.error('Error getting dashboard stats:', error);
        res.status(500).json({ 
          status: 'error', 
          message: 'Failed to get dashboard stats',
          error: error instanceof Error ? error.message : String(error)
        });
      }
    });
    
    // User routes
    log('[Routes] Setting up user routes...');
    
    app.use('/api/users', authenticateSession, usersRouter);
    
    // Project routes
    log('[Routes] Setting up project routes...');
    
    // Allow public access to projects for public document creation
    app.get('/api/projects/search', async (req: Request, res: Response) => {
      try {
        let query = req.query.q as string;
        console.log(`[Projects] Search query: "${query}"`);
        
        if (!query) {
          return res.json({ data: [] });
        }
        
        // Replace Ν with N in the query if present (common issue with Greek/Latin characters)
        const cleanedQuery = query
          .replace(/Ν/g, 'N')  // Greek Ν to Latin N
          .replace(/\s+/g, ''); // Remove whitespace
        
        console.log(`[Projects] Cleaned search query: "${cleanedQuery}"`);
        
        // Search by various project identifiers
        const { data, error } = await supabase
          .from('Projects')
          .select('*')
          .or(`na853.ilike.%${cleanedQuery}%,project_title.ilike.%${query}%,mis.ilike.%${query}%,expenditure.ilike.%${query}%`)
          .limit(20);
        
        if (error) {
          console.error('[Projects] Search error:', error);
          return res.status(500).json({ 
            message: 'Error searching projects', 
            error: error.message 
          });
        }
        
        console.log(`[Projects] Found ${data?.length || 0} results`);
        res.json({ data: data || [] });
      } catch (error) {
        console.error('[Projects] Search error:', error);
        res.status(500).json({ 
          message: 'Error searching projects', 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    });
    
    // Use authentication for all other project routes
    app.use('/api/projects', authenticateSession, projectRouter);
    app.use('/api/catalog', authenticateSession, projectRouter);

    // Budget routes
    log('[Routes] Setting up budget routes...');
    
    // Allow public access to budget data by MIS for document creation
    // Using our specialized controller function for MIS lookups
    app.get('/api/budget/:mis', getBudgetByMis);

    // Budget notifications routes - must be registered BEFORE the main budget routes
    log('[Routes] Setting up budget notifications routes...');
    app.use('/api/budget-notifications', authenticateSession, budgetNotificationsRouter);
    log('[Routes] Budget notifications routes setup complete');
    
    // Use authentication for all other budget routes
    log('[Routes] Setting up authenticated budget routes...');
    app.use('/api/budget', authenticateSession, budgetRouter);
    log('[Routes] Budget routes setup complete');
    
    // Budget upload routes - must be registered after budget routes to prevent conflicts
    log('[Routes] Setting up budget upload routes...');
    app.use('/api/budget', authenticateSession, budgetUploadRouter);
    log('[Routes] Budget upload routes setup complete');
    
    // Documents routes
    log('[Routes] Setting up document routes...');
    
    // Public document access by ID - no authentication required
    app.get('/api/documents/public/:id', async (req, res) => {
      try {
        const { id } = req.params;
        
        if (!id) {
          return res.status(400).json({ message: 'Document ID is required' });
        }
        
        console.log('[Documents] Public access to document ID:', id);
        
        // Get document by ID
        const { data, error } = await supabase
          .from('generated_documents')
          .select('*')
          .eq('id', id)
          .single();
        
        if (error) {
          console.error('[Documents] Error fetching document:', error);
          return res.status(404).json({ message: 'Document not found' });
        }
        
        if (!data) {
          return res.status(404).json({ message: 'Document not found' });
        }
        
        // Redact sensitive information for public access
        const publicDocument = {
          ...data,
          // Redact sensitive recipient info but keep payment details
          recipients: data.recipients.map((recipient: any) => ({
            ...recipient,
            // Keep just the last 4 digits of AFM
            afm: recipient.afm ? `***${recipient.afm.slice(-4)}` : '********',
            // Only include the first letter of names
            firstname: recipient.firstname ? `${recipient.firstname.charAt(0)}...` : '',
            lastname: recipient.lastname ? `${recipient.lastname.charAt(0)}...` : '',
            fathername: recipient.fathername ? `${recipient.fathername.charAt(0)}...` : ''
          }))
        };
        
        res.json({ status: 'success', data: publicDocument });
      } catch (error) {
        console.error('[Documents] Error in public document access:', error);
        res.status(500).json({ 
          message: 'Error accessing document', 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      }
    });
    
    // Authenticated document routes
    app.use('/api/documents', authenticateSession, documentsRouter);
    
    // Template preview routes
    app.use('/api/templates', authenticateSession, templatePreviewRouter);
    
    // Units handling
    log('[Routes] Setting up unit routes...');
    
    // Public units endpoint for document creation
    app.get('/api/users/units', async (req, res) => {
      try {
        console.log('[Units] Public access to units list');
        
        // Get units list - read from environment if available, otherwise from database
        let units: any[] = [];
        
        if (process.env.UNITS_JSON) {
          try {
            units = JSON.parse(process.env.UNITS_JSON);
            console.log(`[Units] Loaded ${units.length} units from environment variable`);
          } catch (err) {
            console.error('[Units] Error parsing UNITS_JSON environment variable:', err);
          }
        }
        
        // If units not available from environment, try database
        if (!units.length) {
          const { data, error } = await supabase
            .from('units')
            .select('*')
            .order('title', { ascending: true });
          
          if (error) {
            console.error('[Units] Error fetching units from database:', error);
          } else if (data) {
            units = data;
            console.log(`[Units] Loaded ${units.length} units from database`);
          }
        }
        
        // Return the units list
        res.json({ data: units });
      } catch (error) {
        console.error('[Units] Error in public units access:', error);
        res.status(500).json({ 
          message: 'Error accessing units', 
          error: error instanceof Error ? error.message : 'Unknown error'  
        });
      }
    });
    
    // Units routes
    app.use('/api/units', authenticateSession, unitsRouter);
    
    // Other routes
    log('[Routes] Setting up additional routes...');
    
    // Attachments router
    app.use('/api/attachments', attachmentsRouter);
    
    // API router (for middleware and utility endpoints)
    app.use('/api', apiRouter);
    
    // Health check routes
    app.use('/api/healthcheck', healthcheckRouter);
    app.use('/api/health', healthRouter);
    
    // System diagnostic routes
    app.use('/api/diagnostic', sdegdaefkDiagnosticRouter);
    
    // API Documentation - Swagger/OpenAPI
    app.get('/api-docs', (req, res) => {
      res.send(`
        <html>
        <head>
          <title>API Documentation</title>
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.25.0/swagger-ui.css">
          <script src="https://cdn.jsdelivr.net/npm/swagger-ui-dist@3.25.0/swagger-ui-bundle.js"></script>
        </head>
        <body>
          <div id="swagger-ui"></div>
          <script>
            window.onload = function() {
              SwaggerUIBundle({
                url: "/api-docs/openapi.json",
                dom_id: '#swagger-ui',
                presets: [
                  SwaggerUIBundle.presets.apis,
                  SwaggerUIBundle.SwaggerUIStandalonePreset
                ],
                layout: "BaseLayout"
              })
            }
          </script>
        </body>
        </html>
      `);
    });
    
    // OpenAPI schema
    app.get('/api-docs/openapi.json', (req, res) => {
      res.json({
        openapi: '3.0.0',
        info: {
          title: 'Budget Management API',
          version: '2.0.0',
          description: 'API documentation for the Budget Management System'
        },
        servers: [
          {
            url: 'https://sdegdaefk.gr/api',
            description: 'Production server'
          },
          {
            url: '/api',
            description: 'Development server'
          }
        ],
        paths: {
          // TODO: Autogenerate from routes
        }
      });
    });
    
    // Log the registered routes in development mode
    if (process.env.NODE_ENV !== 'production') {
      // Helper function to extract routes
      function extractRoutes(stack: any[], basePath = '') {
        const routes: string[] = [];
        
        for (const layer of stack) {
          if (layer.route) {
            // Routes registered directly on the app
            const path = layer.route.path;
            const methods = Object.keys(layer.route.methods).map(m => m.toUpperCase()).join(',');
            routes.push(`${methods} ${basePath}${path}`);
          } else if (layer.name === 'router' && layer.handle.stack) {
            // Middleware registered with app.use
            const path = layer.regexp.source.replace('^\\/(?=\\/|$)|\\/$', '').replace(/\\\//g, '/');
            const subRoutes = extractRoutes(layer.handle.stack, basePath + path);
            routes.push(...subRoutes);
          }
        }
        
        return routes;
      }
      
      // Extract and log all routes
      const routes = extractRoutes((app as any)._router.stack);
      console.log('\n[Routes] Registered routes:');
      routes.forEach(route => console.log(`- ${route}`));
    }
    
    // Create HTTP server
    const server = createServer(app);
    
    // Return the server instance
    return server;
  } catch (error) {
    console.error('[Routes] Error setting up routes:', error);
    throw error;
  }
}