🚨 Functional / Logic Bugs

Municipality “id” vs “code” mismatch (breaks display + path preview)

You set selectedMunicipalityId sometimes to a code (on init) and sometimes to the id like "municipality-<code>" (on user selection).

Later you compare municipality.code === Number(selectedMunicipalityId) which will fail when selectedMunicipalityId is the string id.

Fix (pick one approach and keep it everywhere): use code consistently:

When populating availableMunicipalities, also expose a value that equals the code (string).

Make the Select use that code for both value and onValueChange.

Update all finds to compare String(m.code) === selectedMunicipalityCode (no Number()).

// When building projectGeographicAreas (keep everything as strings):
availableMunicipalities: uniqueMunicipalities.map((item:any) => {
  const code = String(item.muni_code || item.municipalities?.code);
  return {
    id: `municipality-${code}`,
    code,                               // ensure string
    name: item.municipalities?.name || item.name,
    type: "municipality",
    unit_code: String(item.municipalities?.unit_code ?? ""),
  };
}),

// In state:
const [selectedMunicipalityCode, setSelectedMunicipalityCode] = useState<string>("");

// Select:
<Select
  value={selectedMunicipalityCode}
  onValueChange={(code) => {
    geoUserInteractedRef.current = true;
    const m = availableMunicipalities.find((mm:any) => mm.code === code);
    if (m) {
      const parentUnit = ((projectGeographicAreas as any)?.availableUnits || [])
        .find((u:any) => u.code === m.unit_code);

      isProgrammaticUpdateRef.current = true;
      if (parentUnit) {
        setSelectedUnitFilter(parentUnit.code);
        if (parentUnit.region_code) setSelectedRegionFilter(parentUnit.region_code);
      }
      setTimeout(() => { isProgrammaticUpdateRef.current = false; }, 0);

      // if you keep form.region as JSON, don't push a name string here (see note 4 below)
      setSelectedMunicipalityCode(code);
    }
  }}
>
  <SelectContent className="max-h-60">
    {availableMunicipalities.map((m:any) => (
      <SelectItem key={m.code} value={m.code}>
        {m.name}
      </SelectItem>
    ))}
  </SelectContent>
</Select>

// Path preview (compare strings; no Number()):
const municipality = areas?.availableMunicipalities?.find(
  (m:any) => m.code === selectedMunicipalityCode
);


Do the same “string code everywhere” treatment for selectedRegionFilter and selectedUnitFilter. Avoid Number() conversions entirely.

Status Select shows wrong badge color in the menu

Inside the menu items you use className={statusOption?.color} which is the current status, not the iterated option.

Fix:

<SelectContent>
  {STATUS_OPTIONS.map((option) => (
    <SelectItem key={option.value} value={option.value}>
      <Badge className={option.color}>{option.label}</Badge>
    </SelectItem>
  ))}
</SelectContent>


SelectValue misuse (shadcn/ui)

SelectValue doesn’t render arbitrary children; it renders the currently selected item’s text. Putting a <Badge> inside SelectValue won’t work as intended.

Fix: Show the badge above/beside the Select, or keep the Select text-only and render a badge elsewhere (e.g., next to the label).

region field type inconsistency

In several places you do form.setValue("region", selectedUnit.name) or a municipality/region name (string), but in the mutation you send region as a JSON object { region_code, region_name, ... }. This will cause schema/type problems.

Fix (recommended): keep form.getValues("region") either:

Always a JSON object (preferred), and only update it with {region_code,...} from the selected filters, OR

Never touch it in UI and only build the JSON object inside the mutation (based on the 3 filters).
Right now you’re mixing string + object. Remove all form.setValue("region", <string>) calls; only set region in the mutation using selected codes.

Project Select is bound to project_index_id field but uses project id

The <FormField name="project_index_id"> is rendered, but the select’s value is selectedProjectId (project.id) and you don’t call field.onChange. That’s confusing to RHF and to readers.

You later compute and set the real project_index_id via findAndUpdateProjectIndex. That’s fine, but then the FormField name should not be project_index_id.

Fix (cleanest):

Change the field name to a display-only value: e.g. name="project_id_ui" (or remove FormField wrapper and use a plain Select).

Keep selectedProjectId state as you do and compute project_index_id with findAndUpdateProjectIndex.

Query key includes large/unstable objects (causes cache misses)

queryKey: ['project-expenditure-types', selectedProjectId, selectedUnitId, allExpenditureTypes] includes the entire allExpenditureTypes array—this makes the key unstable.

Fix: only use scalar parts in keys:

queryKey: ['project-expenditure-types', selectedProjectId, selectedUnitId, (allExpenditureTypes?.length ?? 0)]


…and read allExpenditureTypes inside queryFn.

Comparisons mixing string/number

There are multiple Number(...) casts when finding region/unit/municipality, while you store codes as strings elsewhere.

Fix: treat all codes as strings everywhere.

⚠️ Smaller Issues / UX / Maintainability

Duplicate empty state for recipients: You render the “Δεν υπάρχουν δικαιούχοι” block twice (before and after the map). Remove one.

Unused imports: Calendar, ScrollArea appear unused.

isLoading vs mutation state: You maintain your own isLoading while useMutation already gives isPending. Consider deriving button/disabled state from updateMutation.isPending to avoid desync.

FormField for AFM validation: You wrap SimpleAFMAutocomplete and then immediately a FormField just to show <FormMessage />. That’s okay, but you can attach FormMessage to one FormField only.

units filter: If user.unit_id can be a single number instead of array, your mapping to map(String) on (user?.unit_id ?? []) will yield []. Make sure unit_id is always an array or normalize:

const userUnitIds = useMemo(() => {
  const ids = user?.unit_id;
  return Array.isArray(ids) ? ids.map(String) : ids != null ? [String(ids)] : [];
}, [user?.unit_id]);

✅ Suggested code edits (minimal & targeted)

A) Normalize all geo codes to strings and keep region out of the form until submit

Remove all form.setValue("region", ...) lines.

Keep three states: selectedRegionCode, selectedUnitCode, selectedMunicipalityCode (strings).

Build the region JSON once in mutationFn:

const regionData = (() => {
  const areas = projectGeographicAreas as any;
  if (!areas) return data.region || null;

  const region = areas.availableRegions?.find((r:any) => r.code === selectedRegionFilter);
  const unit = areas.availableUnits?.find((u:any) => u.code === selectedUnitFilter);
  const municipality = areas.availableMunicipalities?.find((m:any) => m.code === selectedMunicipalityId);

  if (!region && !unit && !municipality) return data.region || null;

  return {
    region_code: region?.code,
    region_name: region?.name,
    unit_code: unit?.code,
    unit_name: unit?.name,
    municipality_code: municipality?.code,
    municipality_name: municipality?.name,
  };
})();


B) Fix path preview comparisons

const parts:string[] = [];
const region = areas?.availableRegions?.find((r:any) => r.code === selectedRegionFilter);
if (region) parts.push(region.name);
const unit = areas?.availableUnits?.find((u:any) => u.code === selectedUnitFilter);
if (unit) parts.push(unit.name);
const municipality = areas?.availableMunicipalities?.find((m:any) => m.code === selectedMunicipalityId);
if (municipality) parts.push(municipality.name);
return parts.length ? parts.join(' → ') : 'Καμία επιλογή';


C) Fix Status menu item color

<SelectItem key={option.value} value={option.value}>
  <Badge className={option.color}>{option.label}</Badge>
</SelectItem>


D) Decouple “Project” select from project_index_id field

Change name="project_index_id" to name="project_id_ui" (or remove FormField wrapper) to avoid RHF confusion.

If you want, paste your editDocumentSchema / correctionDocumentSchema and I’ll validate that the region type and project_index_id requirements align with the UI behavior above.